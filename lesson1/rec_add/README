Go语言的 rpc 包提供对通过网络或其他 i/o 连接导出的对象方法的访问
1. 服务器注册一个对象，并把它作为服务对外可见（服务名称就是类型名称）注册后对象的导出方法支持远程访问。
* 服务器可以注册不同类型的多个对象，但是不支持注册同一类型的多个对象 



服务端步骤：
1. 定义类型：定义方法：为该类型注册一个可导出的方法，这个方法就支持远程调用（类似本地进行调用）
2. 注册服务：将定义的类型注册为一个服务，该类型定义的方法就支持RPC调用 

客户端步骤：
1. 建立http连接 Dialxxx建立网络连接 
* Dial是建立tpc连接,DialHttp是建立http连接
2 调用远程服务，使用连接返回的客户端，调用远程服务，分为同步调用和异步调用 





**基于http进行调用**
* rpc.Register(service) 注册 RPC 服务
* rpc.HandleHTTP() 基于 HTTP 协议处理 RPC 调用
* net.Listen("tcp",":9091") 监听端口 9091 上的 TCP 连接
* http.Serve(l,nil) 启动 HTTP 服务

*基于tcp服务进行调用*
当有客户端发起对 ServiceA 服务上的 Add 方法的 RPC 请求时，
该程序将会接受连接，并使用 rpc.ServeConn 处理该连接上的所有请求。rpc.ServeConn 函数会阻塞当前 goroutine 直到当前连接关闭或出现错误。
循环是因为 l.Accept() 是一个阻塞调用，它会一直等待客户端的连接请求。在有客户端发起连接请求时，该函数将会返回一个新的 net.Conn 连接实例。

因此，在这个 for 循环中，程序将会一直监听来自客户端的连接请求并处理它们。每当有新的连接请求时，程序将使用 rpc.ServeConn(conn) 函数来处理该连接上的所有 RPC 请求，直到连接关闭或出现错误。



同步调用和异步调用是两种不同的 RPC 调用方式，它们的主要区别在于调用方等待结果的方式不同。
同步调用（Synchronous Call）：发起 RPC 调用后，调用方会一直等待着远程服务端返回结果，期间阻塞当前线程。只有当远程服务端返回结果或者超时异常抛出时，调用方才会继续处理之后的逻辑。这种方式通常使用简单、易于理解、实现难度低，但是对系统资源占用高，可能导致性能问题。
异步调用（Asynchronous Call）：发起 RPC 调用后，调用方并不会一直等待远程服务端返回结果，而是立即返回一个占位符给调用方，告知它任务已经提交，可以继续进行之后的操作。同时，RPC 框架还会在后台创建一个新的线程或任务来处理该调用，并在最终结果返回时通知调用方。这种方式通常使用灵活、性能高，但是实现较为复杂。
在实际应用中，我们需要根据具体的业务需求和技术场景选择合适的调用方式。例如：

如果我们希望系统性能更高，可以使用异步调用方式。例如，如果我们要进行批量数据处理操作，可以将每个数据项分配给不同的线程或任务，并使用异步调用方式来处理这些任务，以提高系统的处理能力和效率。
如果我们要进行在线交互操作，通常需要使用同步调用方式。例如，如果我们要向远程服务端查询某个用户的信息并显示在前端界面上，就需要使用同步调用方式来等待服务端的结果返回，并及时更新前端页面。